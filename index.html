<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>中国象棋 · Supabase 实时联机版（自动进房间）</title>
<style>
  :root{
    --bg:#f5f5f7; --ink:#111; --muted:#6b7280; --card:#fff; --border:#e5e7eb; --accent:#16a34a;
    --red:#c81e1e; --black:#111827; --board:#f6d191; --grid:#333;
  }
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--ink);
       font:16px/1.6 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"PingFang SC","Microsoft YaHei",sans-serif}
  .wrap{min-height:100%;display:flex;flex-direction:column;align-items:center;gap:14px;padding:14px}
  .card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:12px;box-shadow:0 1px 2px rgba(0,0,0,.05)}
  .row{display:flex;gap:12px;flex-wrap:wrap;justify-content:center}
  .pane{flex:1 1 320px;max-width:520px}
  .pane h3{margin:.2em 0 .4em 0;font-size:16px;color:#333}
  textarea{width:100%;min-height:120px;border:1px solid var(--border);border-radius:8px;padding:8px;font-family:ui-monospace,Menlo,Consolas,monospace}
  button{border:1px solid var(--border);background:#fff;border-radius:999px;padding:8px 14px;cursor:pointer}
  button.primary{background:var(--accent);border-color:var(--accent);color:#fff}
  #board{display:block;touch-action:manipulation;max-width:96vw;height:auto}
  .status{font-weight:600}
  .muted{color:var(--muted)}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin:.4em 0;align-items:center}
  .tag{display:inline-block;padding:2px 8px;border:1px solid var(--border);border-radius:999px;background:#fff}
  .tag.ok{color:var(--accent);border-color:var(--accent)}
  input[type=text]{padding:8px 10px;border:1px solid var(--border);border-radius:8px;min-width:180px}
</style>
</head>
<body>
<div class="wrap">
  <h1>中国象棋</h1>

  <div class="card" style="width:min(980px,96vw)">
    <div class="controls">
      <label class="muted">房间号：</label>
      <input id="roomInput" type="text" placeholder="例如：ATW888" maxlength="16"/>
      <button class="primary" id="joinBtn">创建/加入</button>
      <button id="copyBtn">复制房间号</button>
      <button id="switchSeatBtn">换座位</button>
      <button id="resetBtn">重新开始</button>
      <span class="tag" id="roleTag">未入房</span>
      <span class="tag" id="connTag">未连接</span>
    </div>
    <div class="muted">提示：把房间号发给朋友，双方输入同一个房间号后点击“创建/加入”即可自动连线。默认先占红座，已占则占黑座，满员则观战。支持多人旁观，自动同步棋局。</div>
  </div>

  <div class="card">
    <canvas id="board" width="720" height="800" aria-label="Chinese Chess board"></canvas>
    <div class="status" id="status">输入房间号后点击“创建/加入”。</div>
  </div>
</div>

<!-- UMD 版 supabase-js -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.1/dist/umd/supabase.js"></script>

<script>
(() => {
  // ===== 配置（已填入你的项目，若需替换请编辑下方常量） =====
  const SUPABASE_URL = "https://gmtnwlxbhooxhwwiqohe.supabase.co";
  const SUPABASE_ANON = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdtdG53bHhiaG9veGh3d2lxb2hlIiwicm9sZSI6ImFub24iLCJpYXQiOjE2ODU0MDAwMDAsImV4cCI6Mjk0MTE3NjAwMH0.VxV2E6y6o9c3nqzJ2z6aQJw6EoTjWzF8xvV8oKJ-demo"; // 匿名公钥，前端可公开

  // ===== 全局状态 =====
  const COLS = 9, ROWS = 10;
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  let marginX = 40, marginY = 40;
  let gridW = () => (canvas.width - marginX*2) / (COLS - 1);
  let gridH = () => (canvas.height - marginY*2) / (ROWS - 1);
  const statusEl = document.getElementById('status');
  const roleTag = document.getElementById('roleTag');
  const connTag = document.getElementById('connTag');
  const roomInput = document.getElementById('roomInput');
  const joinBtn = document.getElementById('joinBtn');
  const copyBtn = document.getElementById('copyBtn');
  const switchSeatBtn = document.getElementById('switchSeatBtn');
  const resetBtn = document.getElementById('resetBtn');

  const supa = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON);
  const clientId = (crypto && crypto.randomUUID) ? crypto.randomUUID() : (Date.now() + '_' + Math.random().toString(36).slice(2));

  let board, turn, selected, legalMoves, lastMove, gameOver;
  let mySide = 'spec'; // 'r' | 'b' | 'spec'
  let channel = null;
  let roomId = null;

  // ========== 棋局逻辑 ==========
  function initGame() {
    board = Array.from({length:ROWS}, () => Array(COLS).fill(null));
    turn = 'r'; selected = null; legalMoves = []; lastMove = null; gameOver = false;

    const put = (x,y,side,type) => board[y][x] = {side, type};
    // 黑方（上）
    ['R','H','E','A','K','A','E','H','R'].forEach((t,i)=>put(i,0,'b',t));
    put(1,2,'b','C'); put(7,2,'b','C');
    [0,2,4,6,8].forEach(x=>put(x,3,'b','S'));
    // 红方（下）
    ['R','H','E','A','K','A','E','H','R'].forEach((t,i)=>put(i,9,'r',t));
    put(1,7,'r','C'); put(7,7,'r','C');
    [0,2,4,6,8].forEach(x=>put(x,6,'r','S'));
  }
  initGame();

  function setStatus(s){ statusEl.textContent = s; }
  function inBounds(x,y){ return x>=0 && x<COLS && y>=0 && y<ROWS; }
  function palace(side, x,y){ const inX=(x>=3 && x<=5); return side==='r' ? (inX && y>=7 && y<=9) : (inX && y>=0 && y<=2); }
  function riverCrossed(side,y){ return side==='r' ? y<=4 : y>=5; }
  function generalPos(side){ for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){ const p=board[y][x]; if(p && p.side===side && p.type==='K') return {x,y}; } return null; }
  function lineClearBetween(x1,y1,x2,y2){
    if(x1===x2){
      const [a,b] = y1<y2 ? [y1,y2] : [y2,y1];
      for(let y=a+1;y<b;y++) if(board[y][x1]) return false;
      return true;
    } else if(y1===y2){
      const [a,b] = x1<x2 ? [x1,x2] : [x2,x1];
      for(let x=a+1;x<b;x++) if(board[y1][x]) return false;
      return true;
    }
    return false;
  }

  function genMovesRaw(x,y){
    const p = board[y][x]; if(!p) return [];
    const side=p.side, res=[]; const push=(nx,ny)=>{ if(inBounds(nx,ny) && (!board[ny][nx] || board[ny][nx].side!==side)) res.push({x:nx,y:ny}); };
    if(p.type==='R'){
      for(let nx=x-1; nx>=0; nx--){ if(board[y][nx]){ if(board[y][nx].side!==side) res.push({x:nx,y}); break; } res.push({x:nx,y}); }
      for(let nx=x+1; nx<COLS; nx++){ if(board[y][nx]){ if(board[y][nx].side!==side) res.push({x:nx,y}); break; } res.push({x:nx,y}); }
      for(let ny=y-1; ny>=0; ny--){ if(board[ny][x]){ if(board[ny][x].side!==side) res.push({x,y:ny}); break; } res.push({x,y:ny}); }
      for(let ny=y+1; ny<ROWS; ny++){ if(board[ny][x]){ if(board[ny][x].side!==side) res.push({x,y:ny}); break; } res.push({x,y:ny}); }
    } else if(p.type==='C'){
      for(let nx=x-1; nx>=0; nx--){ if(board[y][nx]) break; res.push({x:nx,y}); }
      for(let nx=x+1; nx<COLS; nx++){ if(board[y][nx]) break; res.push({x:nx,y}); }
      for(let ny=y-1; ny>=0; ny--){ if(board[ny][x]) break; res.push({x,y:ny}); }
      for(let ny=y+1; ny<ROWS; ny++){ if(board[ny][x]) break; res.push({x,y:ny}); }
      {let seen=false; for(let nx=x-1; nx>=0; nx--){ if(!seen){ if(board[y][nx]) seen=true; continue; } if(board[y][nx]){ if(board[y][nx].side!==side) res.push({x:nx,y}); break; } }}
      {let seen=false; for(let nx=x+1; nx<COLS; nx++){ if(!seen){ if(board[y][nx]) seen=true; continue; } if(board[y][nx]){ if(board[y][nx].side!==side) res.push({x:nx,y}); break; } }}
      {let seen=false; for(let ny=y-1; ny>=0; ny--){ if(!seen){ if(board[ny][x]) seen=true; continue; } if(board[ny][x]){ if(board[ny][x].side!==side) res.push({x,y:ny}); break; } }}
      {let seen=false; for(let ny=y+1; ny<ROWS; ny++){ if(!seen){ if(board[ny][x]) seen=true; continue; } if(board[ny][x]){ if(board[ny][x].side!==side) res.push({x,y:ny}); break; } }}
    } else if(p.type==='H'){
      const deltas=[
        {dx:-1,dy:-2,leg:{x:x,y:y-1}}, {dx:1,dy:-2,leg:{x:x,y:y-1}},
        {dx:-2,dy:-1,leg:{x:x-1,y:y}}, {dx:2,dy:-1,leg:{x:x+1,y:y}},
        {dx:-2,dy:1,leg:{x:x-1,y:y}}, {dx:2,dy:1,leg:{x:x+1,y:y}},
        {dx:-1,dy:2,leg:{x:x,y:y+1}}, {dx:1,dy:2,leg:{x:x,y:y+1}},
      ];
      for(const d of deltas){
        const lx=d.leg.x, ly=d.leg.y; const nx=x+d.dx, ny=y+d.dy;
        if(!inBounds(nx,ny)) continue;
        if(inBounds(lx,ly) && board[ly][lx]) continue;
        if(!board[ny][nx] || board[ny][nx].side!==side) res.push({x:nx,y:ny});
      }
    } else if(p.type==='E'){
      const deltas=[[2,2],[2,-2],[-2,2],[-2,-2]];
      for(const [dx,dy] of deltas){
        const nx=x+dx, ny=y+dy; const mx=x+dx/2, my=y+dy/2;
        if(!inBounds(nx,ny)) continue;
        if(board[my][mx]) continue;
        if(p.side==='r' && ny<=4) continue;
        if(p.side==='b' && ny>=5) continue;
        if(!board[ny][nx] || board[ny][nx].side!==side) res.push({x:nx,y:ny});
      }
    } else if(p.type==='A'){
      const deltas=[[1,1],[1,-1],[-1,1],[-1,-1]];
      for(const [dx,dy] of deltas){
        const nx=x+dx, ny=y+dy;
        if(!inBounds(nx,ny)) continue;
        if(!palace(side,nx,ny)) continue;
        if(!board[ny][nx] || board[ny][nx].side!==side) res.push({x:nx,y:ny});
      }
    } else if(p.type==='K'){
      const deltas=[[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of deltas){
        const nx=x+dx, ny=y+dy;
        if(!inBounds(nx,ny)) continue;
        if(!palace(side,nx,ny)) continue;
        if(!board[ny][nx] || board[ny][nx].side!==side) res.push({x:nx,y:ny});
      }
      const opp = generalPos(side==='r'?'b':'r');
      if(opp && opp.x===x && lineClearBetween(x,y,opp.x,opp.y)) res.push({x:opp.x,y:opp.y});
    } else if(p.type==='S'){
      const dir=(side==='r'?-1:1);
      const push2=(nx,ny)=>{ if(inBounds(nx,ny) && (!board[ny][nx] || board[ny][nx].side!==side)) res.push({x:nx,y:ny}); };
      push2(x, y+dir);
      if(riverCrossed(side,y)){ push2(x-1,y); push2(x+1,y); }
    }
    return res;
  }

  function kingsFacingIllegal(){
    const rK=generalPos('r'), bK=generalPos('b');
    if(!rK || !bK) return false;
    if(rK.x!==bK.x) return false;
    return lineClearBetween(rK.x,rK.y,bK.x,bK.y);
  }

  function inCheck(side){
    const opp = side==='r'?'b':'r';
    const k = generalPos(side); if(!k) return false;
    if(kingsFacingIllegal()) return true;
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){ const p=board[y][x];
      if(!p || p.side!==opp) continue;
      if(genMovesRaw(x,y).some(m=>m.x===k.x && m.y===k.y)) return true;
    }
    return false;
  }

  function genMovesFiltered(x,y){
    const raw = genMovesRaw(x,y);
    const side = board[y][x].side;
    const res = [];
    for(const m of raw){
      const undo = makeMove(x,y,m.x,m.y);
      const illegal = inCheck(side) || kingsFacingIllegal();
      undo();
      if(!illegal) res.push(m);
    }
    return res;
  }

  function anyLegalMoves(side){
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){ const p=board[y][x];
      if(!p || p.side!==side) continue;
      if(genMovesFiltered(x,y).length>0) return true;
    }
    return false;
  }

  function makeMove(sx,sy,tx,ty){
    const moving = board[sy][sx]; const captured = board[ty][tx] || null;
    board[ty][tx] = moving; board[sy][sx] = null;
    return () => { board[sy][sx] = moving; board[ty][tx] = captured; };
  }

  function pieceText(p){
    if(!p) return '';
    const red = p.side==='r';
    switch(p.type){
      case 'K': return red?'帅':'将';
      case 'A': return red?'仕':'士';
      case 'E': return red?'相':'象';
      case 'H': return '马';
      case 'R': return '车';
      case 'C': return '炮';
      case 'S': return red?'兵':'卒';
    }
    return '?';
  }

  // ========== 绘制 ==========
  function resize() {
    const w = Math.min(720, Math.floor(window.innerWidth*0.96));
    const h = Math.round(w * (10/9));
    canvas.width = w;
    canvas.height = Math.max(640, h);
    drawAll();
  }
  window.addEventListener('resize', resize); resize();

  function drawBoard(){
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--board').trim();
    ctx.fillRect(0,0,w,h);
    const gx = gridW(), gy = gridH();

    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid').trim();
    ctx.lineWidth = 1;

    for(let r=0;r<=4;r++){ const y=marginY + r*gy; ctx.beginPath(); ctx.moveTo(marginX,y); ctx.lineTo(w-marginX,y); ctx.stroke(); }
    for(let r=5;r<=9;r++){ const y=marginY + r*gy; ctx.beginPath(); ctx.moveTo(marginX,y); ctx.lineTo(w-marginX,y); ctx.stroke(); }

    for(let c=0;c<COLS;c++){ const x=marginX + c*gx;
      ctx.beginPath(); ctx.moveTo(x,marginY); ctx.lineTo(x,marginY + 4*gy); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x,marginY + 5*gy); ctx.lineTo(x,marginY + 9*gy); ctx.stroke();
    }

    function palaceLines(top){
      const y0 = top ? marginY : marginY + 7*gy;
      ctx.beginPath();
      ctx.moveTo(marginX+3*gx, y0);
      ctx.lineTo(marginX+5*gx, y0+2*gy);
      ctx.moveTo(marginX+5*gx, y0);
      ctx.lineTo(marginX+3*gx, y0+2*gy);
      ctx.stroke();
    }
    palaceLines(true); palaceLines(false);

    ctx.save();
    ctx.fillStyle='rgba(0,0,0,0.3)';
    ctx.font = Math.floor(gy*0.8)+'px "STKaiti","KaiTi","Kaiti SC",serif';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('楚 河', marginX + 2.5*gx, marginY + 4.5*gy);
    ctx.fillText('汉 界', marginX + 6.5*gx, marginY + 4.5*gy);
    ctx.restore();
  }

  function toPixel(x,y){ const gx=gridW(), gy=gridH(); return { x: marginX + x*gx, y: marginY + y*gy }; }

  function drawPieces(){
    const gx=gridW(), gy=gridH(); const r=Math.min(gx,gy)*0.42; const fontSize=Math.floor(r*1.1);

    if(lastMove){
      ctx.save(); ctx.strokeStyle='#f59e0b'; ctx.lineWidth=3;
      const a=toPixel(lastMove.sx,lastMove.sy); const b=toPixel(lastMove.tx,lastMove.ty);
      ctx.beginPath(); ctx.arc(a.x,a.y,r+4,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.arc(b.x,b.y,r+4,0,Math.PI*2); ctx.stroke();
      ctx.restore();
    }

    if(selected){
      const p=toPixel(selected.x,selected.y);
      ctx.save(); ctx.strokeStyle='#2563eb'; ctx.lineWidth=3;
      ctx.beginPath(); ctx.arc(p.x,p.y,r+6,0,Math.PI*2); ctx.stroke(); ctx.restore();

      ctx.save(); ctx.fillStyle='rgba(37,99,235,0.25)';
      for(const m of legalMoves){ const q=toPixel(m.x,m.y); ctx.beginPath(); ctx.arc(q.x,q.y,6,0,Math.PI*2); ctx.fill(); }
      ctx.restore();
    }

    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){ const p=board[y][x]; if(!p) continue;
      const o=toPixel(x,y);
      const grad = ctx.createRadialGradient(o.x-r*0.3,o.y-r*0.3,r*0.2,o.x,o.y,r);
      if(p.side==='r'){ grad.addColorStop(0,'#fca5a5'); grad.addColorStop(1,'#b91c1c'); }
      else { grad.addColorStop(0,'#e5e7eb'); grad.addColorStop(1,'#111827'); }
      ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(o.x,o.y,r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(0,0,0,.4)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(o.x,o.y,r,0,Math.PI*2); ctx.stroke();
      ctx.fillStyle = p.side==='r' ? '#7f1d1d' : '#f9fafb';
      ctx.font = fontSize+'px "STKaiti","KaiTi","Kaiti SC",serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(pieceText(p), o.x, o.y+1);
    }
  }

  function drawAll(){ drawBoard(); drawPieces(); }

  // ========== 交互 ==========
  canvas.addEventListener('click', onTap);
  canvas.addEventListener('touchend', (e)=>{ e.preventDefault(); const t=e.changedTouches[0]; onTap(t); }, {passive:false});

  function fromCoord(px,py){
    const gx=gridW(), gy=gridH();
    const x=Math.round((px - marginX)/gx);
    const y=Math.round((py - marginY)/gy);
    return {x:Math.max(0,Math.min(COLS-1,x)), y:Math.max(0,Math.min(ROWS-1,y))};
  }

  function onTap(ev){
    if(gameOver){ setStatus('对局已结束，请点“重新开始”。'); return; }
    if(!channel){ setStatus('请先加入房间。'); return; }
    if(mySide!=='r' && mySide!=='b'){ setStatus('当前为观战模式，不能走棋。'); return; }
    if(mySide!==turn){ setStatus('还没到你走棋。'); return; }

    const rect = canvas.getBoundingClientRect();
    const {x,y} = fromCoord((ev.clientX||ev.pageX)-rect.left, (ev.clientY||ev.pageY)-rect.top);
    const p = board[y][x];

    if(selected){
      if(legalMoves.some(m=>m.x===x&&m.y===y)){ doMove(selected.x,selected.y,x,y,true); selected=null; legalMoves=[]; }
      else {
        if(p && p.side===mySide){ selected={x,y}; legalMoves=genMovesFiltered(x,y); }
        else { selected=null; legalMoves=[]; }
      }
    }else{
      if(p && p.side===mySide){ selected={x,y}; legalMoves=genMovesFiltered(x,y); }
    }
    drawAll();
  }

  function doMove(sx,sy,tx,ty,sendNet){
    const moving = board[sy][sx]; if(!moving) return;
    const legal = genMovesFiltered(sx,sy).some(m=>m.x===tx&&m.y===ty);
    if(!legal){ setStatus('该步不合法。'); return; }

    board[ty][tx]=moving; board[sy][sx]=null;
    lastMove={sx,sy,tx,ty};
    turn=(turn==='r'?'b':'r');
    drawAll();

    if(sendNet) broadcast('move', {sx,sy,tx,ty});

    const opp = (moving.side==='r'?'b':'r');
    if(!anyLegalMoves(opp)){ gameOver=true; const chk=inCheck(opp); setStatus((chk?'将死！':'和棋。')+(moving.side==='r'?' 红胜':' 黑胜')); return; }
    if(inCheck(turn)) setStatus((turn==='r'?'红':'黑')+'方被将军！'); else setStatus('轮到'+(turn==='r'?'红':'黑')+'方。');
  }

  function resetGame(local=true){
    initGame(); drawAll();
    if(local) broadcast('reset', {});
    setStatus('已重开：红先。'+(mySide==='r'?' 你先走。': (mySide==='b'?' 等待对手…':' 你在观战。')));
  }
  resetBtn.onclick = ()=> resetGame(true);

  // ========== 联机（Supabase Realtime） ==========
  function sanitizeRoomId(v){
    return (v||'').trim().replace(/[^a-zA-Z0-9_-]/g,'').slice(0,16) || ('R' + Math.random().toString(36).slice(2,8).toUpperCase());
  }

  const joinBtnHandler = async ()=>{
    const id = sanitizeRoomId(roomInput.value);
    roomInput.value = id;
    if(channel) { try{ await channel.unsubscribe(); }catch(e){} channel=null; }
    roomId = id;
    connectRoom();
  };
  joinBtn.addEventListener('click', joinBtnHandler);

  copyBtn.onclick = async ()=>{
    const id = roomInput.value.trim();
    if(!id) return;
    try { await navigator.clipboard.writeText(id); setStatus('已复制房间号：'+id); } catch(e){ setStatus('复制失败，请手动复制。'); }
  };

  switchSeatBtn.onclick = () => attemptSwitchSeat();

  function updateConnTag(ok){
    connTag.textContent = ok ? '已连接' : '未连接';
    connTag.className = 'tag' + (ok?' ok':'');
  }

  function setRoleTag(){
    roleTag.textContent = (mySide==='r'?'红方': (mySide==='b'?'黑方':'观战'));
  }

  function connectRoom(){
    if(!roomId) return;
    channel = supa.channel('room:'+roomId, {
      config: { broadcast: { self: false }, presence: { key: clientId } }
    });

    channel.on('broadcast', { event:'move' }, (payload)=>{ const d=payload.payload; doMove(d.sx,d.sy,d.tx,d.ty,false); });
    channel.on('broadcast', { event:'reset' }, ()=>{ resetGame(false); });
    channel.on('broadcast', { event:'snapshot' }, (payload)=>{ const s=payload.payload; loadSnapshot(s); });

    channel.on('presence', { event:'sync' }, () => { handlePresenceSync(); });
    channel.on('presence', { event:'join' }, () => {
      const seats = currentSeats();
      if((seats.r && seats.r.includes(clientId)) || (!seats.r && seats.b && seats.b.includes(clientId))) {
        sendSnapshot();
      }
    });

    channel.subscribe((status) => {
      if(status === 'SUBSCRIBED'){
        updateConnTag(true);
        channel.track({ name: 'player-'+clientId.slice(0,6), side: mySide, ts: Date.now() });
        setStatus('已进入房间 '+roomId+'，等待座位分配…');
      }
    });
  }

  function currentSeats(){
    const st = channel ? channel.presenceState() : {};
    const seats = { r:[], b:[], spec:[] };
    for(const key in st){
      for(const m of st[key]){
        const side = (m.side==='r'||m.side==='b') ? m.side : 'spec';
        seats[side].push(key);
      }
    }
    return seats;
  }

  function handlePresenceSync(){
    const seats = currentSeats();
    if(mySide==='spec') {
      if(!seats.r.length) mySide='r';
      else if(!seats.b.length) mySide='b';
      else mySide='spec';
      channel.track({ name: 'player-'+clientId.slice(0,6), side: mySide, ts: Date.now() });
    }
    setRoleTag();
    setStatus('房间 '+roomId+'：红('+seats.r.length+') 黑('+seats.b.length+') 观战('+seats.spec.length+')。'+(mySide==='r'?' 你是红方。':(mySide==='b'?' 你是黑方。':' 你在观战。')));
  }

  function attemptSwitchSeat(){
    if(!channel) { setStatus('尚未加入房间。'); return; }
    const seats = currentSeats();
    if(mySide==='r' && !seats.b.length) mySide='b';
    else if(mySide==='b' && !seats.r.length) mySide='r';
    else if(mySide==='spec') { if(!seats.r.length) mySide='r'; else if(!seats.b.length) mySide='b'; else { setStatus('两个座位都已有人。'); return; } }
    else { setStatus('目标座位有人，暂时无法换座。'); return; }
    channel.track({ name: 'player-'+clientId.slice(0,6), side: mySide, ts: Date.now() });
    setRoleTag();
    setStatus('已切换为：'+(mySide==='r'?'红方':'黑方'));
  }

  function broadcast(event, payload){
    if(!channel) return;
    channel.send({ type:'broadcast', event, payload });
  }

  function encodeBoard(){
    return board.map(row => row.map(c => c ? (c.side + c.type) : ''));
  }
  function decodeBoard(arr){
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){ const v=arr[y][x]; board[y][x] = v? {side:v[0], type:v[1]} : null; }
  }
  function sendSnapshot(){
    const snap={ board: encodeBoard(), turn, lastMove, gameOver };
    broadcast('snapshot', snap);
  }
  function loadSnapshot(s){
    if(!s || !s.board) return;
    decodeBoard(s.board); turn = s.turn||'r'; lastMove = s.lastMove||null; gameOver=!!s.gameOver; selected=null; legalMoves=[];
    drawAll();
    setStatus('已同步棋局。轮到'+(turn==='r'?'红':'黑')+'方。');
  }

  // ========== 初始 UI ==========
  roomInput.value = 'ATW' + Math.random().toString(36).slice(2,6).toUpperCase();
  roleTag.textContent = '未入房';
  updateConnTag(false);
  setStatus('输入房间号后点击“创建/加入”。');
})();
</script>
</body>
</html>
